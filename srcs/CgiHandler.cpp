#include "../includes/CgiHandler.hpp"
#include <sys/wait.h>
#include <unistd.h>
#include <fcntl.h>
#include <filesystem>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <sstream>
#include <vector>
#include <cstdlib>
#include <poll.h>
#include <signal.h>


/**
 * @brief Determines if a request should be handled by CGI.
 *
 * Checks if the matched location has CGI configured and if the request URI's
 * file extension is present in the location's cgi_pass map.
 *
 * @param uri The request URI string.
 * @param location The matched location configuration block.
 * @return true if the request is for a CGI script, false otherwise.
 */
bool CgiHandler::isCgiRequest(const std::string& uri, const ConfigParser::LocationConfig& location) {
    if (location.cgi_pass.empty()) {
        return false;
    }
    
    std::string clean_uri = uri;
    size_t query_pos = uri.find('?');
    if (query_pos != std::string::npos) {
        clean_uri = uri.substr(0, query_pos);
    }
    
    std::string extension = std::filesystem::path(clean_uri).extension().string();
    return !extension.empty() && location.cgi_pass.count(extension);
}

/**
 * @brief Main entry point for executing a CGI script synchronously.
 *
 * This function manages the entire blocking lifecycle of a CGI request:
 * 1. Validates the script path and interpreter.
 * 2. Sets up pipes for communication.
 * 3. Forks a child process to run the script.
 * 4. Writes the request body to the script's stdin.
 * 5. Reads the script's output from its stdout with a timeout.
 * 6. Waits for the child process to terminate.
 * 7. Parses the script's output into an HttpResponse.
 *
 *
 * @param request The full HTTP request object.
 * @param location The matched location configuration block for the request.
 * @return HttpResponse The final response generated by the script or an error response.
 */
HttpResponse CgiHandler::execute(const HttpRequest& request, const ConfigParser::LocationConfig& location) {
    std::string uri = request.getRequestTarget();
    
    // Separate script path from query string
    std::string script_uri = uri;
    size_t query_pos = uri.find('?');
    if (query_pos != std::string::npos) {
        script_uri = uri.substr(0, query_pos);
    }
    
    std::string script_path = location.root + script_uri;

    if (!validateScript(script_path)) {
        return createErrorResponse(HttpUtils::HttpStatusCode::NOT_FOUND, "CGI script not found");
    }
    
    std::string interpreter = getInterpreter(script_path, location);
    if (interpreter.empty()) {
        return createErrorResponse(HttpUtils::HttpStatusCode::INTERNAL_SERVER_ERROR, "No interpreter configured");
    }

    int input_pipe[2], output_pipe[2];
    if (pipe(input_pipe) == -1 || pipe(output_pipe) == -1) {
        return createErrorResponse(HttpUtils::HttpStatusCode::INTERNAL_SERVER_ERROR, "Pipe creation failed");
    }

    const std::string& body = request.getBody();
    if (!body.empty()) {
        write(input_pipe[1], body.c_str(), body.length());
    }
    close(input_pipe[1]);

    auto envp = setupEnvironment(request, script_path);
    
    // Execute child process
    pid_t pid = fork();
    if (pid == 0) {
        // Child process
        dup2(input_pipe[0], STDIN_FILENO);
        dup2(output_pipe[1], STDOUT_FILENO);
        close(input_pipe[0]);
        close(output_pipe[1]);

        const char* args[] = { interpreter.c_str(), script_path.c_str(), nullptr };
        execve(interpreter.c_str(), const_cast<char* const*>(args), envp.get());
        perror("CGI execve failed");
        _exit(EXIT_FAILURE);
    }
    
    if (pid == -1) {
        close(input_pipe[0]);
        close(output_pipe[0]);
        close(output_pipe[1]);
        return createErrorResponse(HttpUtils::HttpStatusCode::INTERNAL_SERVER_ERROR, "Fork failed");
    }
    
    // Parent process - close unused pipe ends
    close(input_pipe[0]);
    close(output_pipe[1]);
    
    // Set up timeout for CGI execution
    struct pollfd pfd;
    pfd.fd = output_pipe[0];
    pfd.events = POLLIN;
    
    std::string output;
    char buffer[CGI_BUFSIZE];
    int timeout_ms = CGI_TIMEOUT * 1000;
    
    while (true) {
        int poll_result = poll(&pfd, 1, timeout_ms);
        
        if (poll_result == 0) {
            // Timeout
            kill(pid, SIGKILL);
            waitpid(pid, nullptr, 0);
            close(output_pipe[0]);
            return createErrorResponse(HttpUtils::HttpStatusCode::GATEWAY_TIMEOUT, "CGI script timeout");
        } else if (poll_result < 0) {
            // Poll error
            kill(pid, SIGKILL);
            waitpid(pid, nullptr, 0);
            close(output_pipe[0]);
            return createErrorResponse(HttpUtils::HttpStatusCode::INTERNAL_SERVER_ERROR, "CGI polling failed");
        }
        
        ssize_t bytes_read = read(output_pipe[0], buffer, CGI_BUFSIZE - 1);
        if (bytes_read > 0) {
            buffer[bytes_read] = '\0';
            output += buffer;
        } else if (bytes_read == 0) {
            break;
        } else {
            break;
        }
    }
    
    close(output_pipe[0]);
    
    // Wait for child process to complete
    int status;
    waitpid(pid, &status, 0);
    
    if (output.empty()) {
        return createErrorResponse(HttpUtils::HttpStatusCode::INTERNAL_SERVER_ERROR, "CGI execution failed");
    }
    
    return parseOutput(output);
}

/**
 * @brief Validates that a CGI script exists and is a regular file.
 *
 * Performs filesystem checks to ensure the script path points to an
 * existing regular file before attempting to execute it.
 *
 * @param script_path The full filesystem path to the CGI script.
 * @return true if the script exists and is a regular file, false otherwise.
 */
HttpResponse CgiHandler::createErrorResponse(HttpUtils::HttpStatusCode status, const std::string& message) {
    HttpResponse response;
    response.setErrorResponse(status, message);
    return response;
}

bool CgiHandler::validateScript(const std::string& script_path) {
    return std::filesystem::exists(script_path) && std::filesystem::is_regular_file(script_path);
}

/**
 * @brief Determines the interpreter path for a CGI script based on its extension.
 *
 * Extracts the file extension from the script path and looks up the
 * corresponding interpreter in the location's cgi_pass configuration.
 *
 * @param script_path The full filesystem path to the CGI script.
 * @param location The location configuration containing CGI interpreter mappings.
 * @return std::string The path to the interpreter, or empty string if not found.
 */
std::string CgiHandler::getInterpreter(const std::string& script_path, const ConfigParser::LocationConfig& location) {
    size_t ext_pos = script_path.find_last_of('.');
    if (ext_pos == std::string::npos) {
        return "";
    }
    
    std::string extension = script_path.substr(ext_pos);
    auto it = location.cgi_pass.find(extension);
    if (it == location.cgi_pass.end()) {
        return "";
    }
    
    return it->second;
}

/**
 * @brief Parses CGI script output into an HTTP response object.
 *
 * Separates CGI headers from the response body and processes them according
 * to CGI specification. Handles both explicit Status headers and default
 * 200 OK responses. Supports both \r\n\r\n and \n\n header separators.
 *
 * @param output The raw output string from the CGI script.
 * @return HttpResponse The parsed HTTP response with headers and body.
 */
HttpResponse CgiHandler::parseOutput(const std::string& output) {
    HttpResponse response;
    size_t header_end = output.find("\r\n\r\n");
    if (header_end == std::string::npos) {
        header_end = output.find("\n\n");
    }
    
    if (header_end != std::string::npos) {
        std::string headers = output.substr(0, header_end);
        std::string response_body = output.substr(header_end + (output.find("\r\n\r\n") != std::string::npos ? 4 : 2));
        
        // Parse headers
        std::istringstream header_stream(headers);
        std::string line;
        bool has_status = false;
        
        while (std::getline(header_stream, line)) {
            if (!line.empty() && line.back() == '\r') {
                line.pop_back();
            }
            
            size_t colon = line.find(':');
            if (colon != std::string::npos) {
                std::string name = line.substr(0, colon);
                std::string value = line.substr(colon + 1);
                value.erase(0, value.find_first_not_of(" \t"));
                
                if (name == "Status") {
                    has_status = true;
                    int status_code = std::stoi(value.substr(0, 3));
                    response.setStatusCode(static_cast<HttpUtils::HttpStatusCode>(status_code));
                } else {
                    response.insertHeader(name, value);
                }
            }
        }
        
        if (!has_status) {
            response.setStatusCode(HttpUtils::HttpStatusCode::OK);
        }
        response.setBody(response_body);
    } else {
        // No headers, treat as plain output
        response.setStatusCode(HttpUtils::HttpStatusCode::OK);
        response.setBody(output);
    }
    
    return response;
}

/**
 * @brief Converts a string map to a C-style environment array for execve().
 *
 * Creates a null-terminated array of C strings in "KEY=VALUE" format
 * suitable for passing to execve(). Uses a custom deleter to ensure
 * proper memory cleanup of both the array and individual strings.
 *
 * @param env_map Map of environment variable names to values.
 * @return std::unique_ptr<char*[]> Smart pointer managing the environment array.
 */
static std::unique_ptr<char*[], void(*)(char**)> mapToEnvArray(const std::map<std::string, std::string>& env_map) {
    auto deleter = [](char** envp) {
        if (envp) {
            for (int i = 0; envp[i]; i++) {
                delete[] envp[i];
            }
            delete[] envp;
        }
    };
    
    char** raw_envp = new char*[env_map.size() + 1];
    int i = 0;
    for (const auto& pair : env_map) {
        std::string env_string = pair.first + "=" + pair.second;
        raw_envp[i] = new char[env_string.length() + 1];
        std::strcpy(raw_envp[i], env_string.c_str());
        i++;
    }
    raw_envp[i] = nullptr;
    
    return std::unique_ptr<char*[], void(*)(char**)>(raw_envp, deleter);
}

/**
 * @brief Sets up the CGI environment variables from the HTTP request.
 *
 * Creates a comprehensive set of CGI environment variables according to
 * the CGI/1.1 specification, including:
 * - Standard CGI variables (REQUEST_METHOD, QUERY_STRING, etc.)
 * - Server information (SERVER_NAME, SERVER_PORT, etc.)
 * - HTTP headers converted to HTTP_* variables
 * - Request body information for POST requests
 *
 * @param request The HTTP request object containing headers and body.
 * @param script_path The full filesystem path to the CGI script.
 * @return std::unique_ptr<char*[]> Environment array suitable for execve().
 */
std::unique_ptr<char*[], void(*)(char**)> CgiHandler::setupEnvironment(const HttpRequest& request, const std::string& script_path) {
    std::map<std::string, std::string> env;
    
    // Basic CGI environment variables
    env["GATEWAY_INTERFACE"] = "CGI/1.1";
    env["REQUEST_METHOD"] = request.getMethod();
    env["SCRIPT_NAME"] = request.getRequestTarget();
    env["SCRIPT_FILENAME"] = script_path;
    env["SERVER_PROTOCOL"] = "HTTP/1.1";
    env["SERVER_SOFTWARE"] = "WebServ/1.0";
    env["REDIRECT_STATUS"] = "200";
    
    // Query string
    std::string uri = request.getRequestTarget();
    size_t query_pos = uri.find('?');
    if (query_pos != std::string::npos) {
        env["QUERY_STRING"] = uri.substr(query_pos + 1);
    } else {
        env["QUERY_STRING"] = "";
    }
    
    // Server info
    if (request.hasHeader("Host")) {
        std::string host = request.getHeader("Host");
        size_t colon_pos = host.find(':');
        if (colon_pos != std::string::npos) {
            env["SERVER_NAME"] = host.substr(0, colon_pos);
            env["SERVER_PORT"] = host.substr(colon_pos + 1);
        } else {
            env["SERVER_NAME"] = host;
            env["SERVER_PORT"] = "80";
        }
    }
    
    // Content info for POST
    if (request.getMethod() == "POST") {
        env["CONTENT_LENGTH"] = std::to_string(request.getBody().length());
        if (request.hasHeader("Content-Type")) {
            env["CONTENT_TYPE"] = request.getHeader("Content-Type");
        }
    }
    
    // HTTP headers - add common ones
    if (request.hasHeader("User-Agent")) {
        env["HTTP_USER_AGENT"] = request.getHeader("User-Agent");
    }
    if (request.hasHeader("Accept")) {
        env["HTTP_ACCEPT"] = request.getHeader("Accept");
    }
    
    // Additional CGI variables
    env["REMOTE_ADDR"] = "127.0.0.1";
    env["PATH_INFO"] = "";
    
    return mapToEnvArray(env);
}


#include <fstream>
#include <sys/stat.h> 
void CgiHandler::test_cgi() {
    std::cout << "\n--- 🧪 Testing CgiHandler ---\n" << std::endl;

    // 1. Create a fake ServerConfig (needed for the LocationConfig constructor)
    ConfigParser::ServerConfig dummy_server;
    dummy_server.port = 8080;
    dummy_server.server_names.push_back("localhost");
    dummy_server.root = "/tmp";

    // 2. Create a fake LocationConfig that enables CGI for .py files
    ConfigParser::LocationConfig location(dummy_server);
    location.root = "/tmp";
    location.cgi_pass[".py"] = "/usr/bin/python3";

    std::cout << "Config:\n" << dummy_server << location << std::endl;

    // 3. Create a simple test script first
    std::string script_path = "/tmp/test.py";
    std::string script_content = R"(#!/usr/bin/python3
print("Content-Type: text/html")
print()
print("<html><body>")
print("<h1>Hello from CGI!</h1>") 
print("<p>This is a test CGI script.</p>")
print("</body></html>")
)";

    // Write the test script
    std::ofstream script_file(script_path);
    if (script_file.is_open()) {
        script_file << script_content;
        script_file.close();
        // Make it executable
        chmod(script_path.c_str(), 0755);
        std::cout << "✓ Created test script at " << script_path << std::endl;
    } else {
        std::cerr << "✗ Failed to create test script" << std::endl;
        return;
    }

    // 4. Create a fake HttpRequest for a GET request to the script
    HttpRequest request;
    request.setMethod("GET");
    request.setRequestTarget("/test.py?user=test");  // Use /test.py instead of /cgi-bin/test.py
    request.setHttpVersion("HTTP/1.1");
    
    // Add some headers that CGI might need
    std::string host = "localhost:8080";
    std::string user_agent = "TestClient/1.0";
    request.insertHeader("Host", host);
    request.insertHeader("User-Agent", user_agent);

    // 5. Check if the CgiHandler correctly identifies it as a CGI request
    std::cout << "Testing isCgiRequest with: " << request.getRequestTarget() << std::endl;
    if (!CgiHandler::isCgiRequest(request.getRequestTarget(), location)) {
        std::cerr << "✗ CGI Test FAILED: isCgiRequest did not detect CGI." << std::endl;
        // Clean up
        unlink(script_path.c_str());
        return;
    }
    std::cout << "✓ isCgiRequest check passed." << std::endl;

    // 6. Execute the CGI handler and get the response
    std::cout << "🚀 Executing CGI script..." << std::endl;
    HttpResponse response = CgiHandler::execute(request, location);

    // 7. Print the results
    std::cout << "\n--- CGI Handler Response ---" << std::endl;
    std::cout << "Status Code: " << static_cast<int>(response.getStatusCode()) << std::endl;
    std::cout << "Response Body:\n" << response.getBody() << std::endl;
    std::cout << "--- End of CGI Response ---\n" << std::endl;

    // 8. Clean up
    unlink(script_path.c_str());
    
    if (response.getStatusCode() == HttpUtils::HttpStatusCode::OK) {
        std::cout << "✅ CGI Test PASSED!" << std::endl;
    } else {
        std::cout << "❌ CGI Test FAILED! Status: " << static_cast<int>(response.getStatusCode()) << std::endl;
    }
    
    std::cout << "--- End of CGI Test ---\n" << std::endl;
}